{"ast":null,"code":"/* eslint \"no-console\": off */\n\nvar intersectLine = require(\"./intersect-line\");\nmodule.exports = intersectPolygon;\n\n/*\n * Returns the point ({x, y}) at which the point argument intersects with the\n * node argument assuming that it has the shape specified by polygon.\n */\nfunction intersectPolygon(node, polyPoints, point) {\n  var x1 = node.x;\n  var y1 = node.y;\n  var intersections = [];\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  polyPoints.forEach(function (entry) {\n    minX = Math.min(minX, entry.x);\n    minY = Math.min(minY, entry.y);\n  });\n  var left = x1 - node.width / 2 - minX;\n  var top = y1 - node.height / 2 - minY;\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect = intersectLine(node, point, {\n      x: left + p1.x,\n      y: top + p1.y\n    }, {\n      x: left + p2.x,\n      y: top + p2.y\n    });\n    if (intersect) {\n      intersections.push(intersect);\n    }\n  }\n  if (!intersections.length) {\n    console.log(\"NO INTERSECTION FOUND, RETURN NODE CENTER\", node);\n    return node;\n  }\n  if (intersections.length > 1) {\n    // More intersections, find the one nearest to edge end point\n    intersections.sort(function (p, q) {\n      var pdx = p.x - point.x;\n      var pdy = p.y - point.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n      var qdx = q.x - point.x;\n      var qdy = q.y - point.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n      return distp < distq ? -1 : distp === distq ? 0 : 1;\n    });\n  }\n  return intersections[0];\n}","map":{"version":3,"names":["intersectLine","require","module","exports","intersectPolygon","node","polyPoints","point","x1","x","y1","y","intersections","minX","Number","POSITIVE_INFINITY","minY","forEach","entry","Math","min","left","width","top","height","i","length","p1","p2","intersect","push","console","log","sort","p","q","pdx","pdy","distp","sqrt","qdx","qdy","distq"],"sources":["C:/Users/emmed/Documents/char_test/frontend/node_modules/dagre-d3/lib/intersect/intersect-polygon.js"],"sourcesContent":["/* eslint \"no-console\": off */\n\nvar intersectLine = require(\"./intersect-line\");\n\nmodule.exports = intersectPolygon;\n\n/*\n * Returns the point ({x, y}) at which the point argument intersects with the\n * node argument assuming that it has the shape specified by polygon.\n */\nfunction intersectPolygon(node, polyPoints, point) {\n  var x1 = node.x;\n  var y1 = node.y;\n\n  var intersections = [];\n\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  polyPoints.forEach(function(entry) {\n    minX = Math.min(minX, entry.x);\n    minY = Math.min(minY, entry.y);\n  });\n\n  var left = x1 - node.width / 2 - minX;\n  var top =  y1 - node.height / 2 - minY;\n\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect = intersectLine(node, point,\n      {x: left + p1.x, y: top + p1.y}, {x: left + p2.x, y: top + p2.y});\n    if (intersect) {\n      intersections.push(intersect);\n    }\n  }\n\n  if (!intersections.length) {\n    console.log(\"NO INTERSECTION FOUND, RETURN NODE CENTER\", node);\n    return node;\n  }\n\n  if (intersections.length > 1) {\n    // More intersections, find the one nearest to edge end point\n    intersections.sort(function(p, q) {\n      var pdx = p.x - point.x;\n      var pdy = p.y - point.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n\n      var qdx = q.x - point.x;\n      var qdy = q.y - point.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n\n      return (distp < distq) ? -1 : (distp === distq ? 0 : 1);\n    });\n  }\n  return intersections[0];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}